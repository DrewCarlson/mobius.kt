{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mobius.kt","text":"<p>Kotlin Multiplatform framework for managing state evolution and side-effects, based on spotify/Mobius.</p> <p>Features:</p> <ul> <li>Support for all Kotlin Multiplatform targets</li> <li>API surface usable from Kotlin, Java, Swift, and Javascript</li> <li>Coroutine and Flow support</li> <li>Testing utilities module</li> <li>Reduced boilerplate with code generation</li> <li>No runtime dependencies (*atomicfu for Native targets)</li> </ul> <p>Getting Started</p> <p>Download</p> <p>API Docs</p>"},{"location":"#what-is-mobius","title":"What is Mobius?","text":"<p>The core construct provided by Mobius is the Mobius Loop, best described by the official documentation. (Embedded below)</p> <p>A Mobius loop is a part of an application, usually including a user interface. In a Spotify context, there is usually one loop per feature such as \u201cthe album page\u201d, \u201clogin flow\u201d, etc., but a loop can also be UI-less and for instance be tied to the lifecycle of an application or a user session.</p>"},{"location":"#mobius-loop","title":"Mobius Loop","text":"<p>A Mobius loop receives Events, which are passed to an Update function together with the current Model. As a result of running the Update function, the Model might change, and Effects might get dispatched. The Model can be observed by the user interface, and the Effects are received and executed by an Effect Handler.</p> <p>'Pure' in the diagram refers to pure functions, functions whose output only depends on their inputs, and whose execution has no observable side effects. See Pure vs Impure Functions for more details.</p> <p>(Source: Spotify/Mobius - Concepts &gt; Mobius Loop)</p>"},{"location":"#why-mobiuskt","title":"Why Mobius.kt","text":"<p>By combining Mobius Loops with Kotlin's Multiplatform features, mobius.kt allows you to write and test Update functions in platform-independent (common) Kotlin and deploy them everywhere. This leaves impure functions to be written in multiplatform Kotlin code or the target platform's primary language (Js, Java, Objective-c/Swift), depending on your use-case.</p>"},{"location":"download/","title":"Download","text":""},{"location":"download/#repository","title":"Repository","text":"<p>Releases are published to Maven Central and snapshots are published to Sonatype OSS. Make sure the required repository is in your build script:</p> <pre><code>repositories {\n    mavenCentral()\n    // Or snapshots\n    maven(\"https://s01.oss.sonatype.org/content/repositories/snapshots/\")\n}\n</code></pre>"},{"location":"download/#kotlin-gradle-script","title":"Kotlin Gradle Script","text":"<pre><code>val mobiusktVersion = \"1.2.2-SNAPSHOT\"\n\ndependencies {\n    implementation(\"org.drewcarlson:mobiuskt-core:$mobiusktVersion\")\n    implementation(\"org.drewcarlson:mobiuskt-test:$mobiusktVersion\")\n    implementation(\"org.drewcarlson:mobiuskt-extras:$mobiusktVersion\")\n    implementation(\"org.drewcarlson:mobiuskt-coroutines:$mobiusktVersion\")\n    implementation(\"org.drewcarlson:mobiuskt-compose:$mobiusktVersion\")\n\n    // Update Spec Generator:\n    implementation(\"org.drewcarlson:mobiuskt-codegen-api:$mobiusktVersion\")\n    ksp(\"org.drewcarlson:mobiuskt-codegen:$mobiusktVersion\")\n}\n</code></pre>"},{"location":"download/#version-catalog-toml","title":"Version Catalog (toml)","text":"<pre><code>[versions]\nmobiuskt = \"1.2.2-SNAPSHOT\"\n\n[libraries]\nmobiuskt-core = { module = \"org.drewcarlson:mobiuskt-core\", version.ref = \"mobiuskt\" }\nmobiuskt-test = { module = \"org.drewcarlson:mobiuskt-test\", version.ref = \"mobiuskt\" }\nmobiuskt-extras = { module = \"org.drewcarlson:mobiuskt-extras\", version.ref = \"mobiuskt\" }\nmobiuskt-coroutines = { module = \"org.drewcarlson:mobiuskt-coroutines\", version.ref = \"mobiuskt\" }\nmobiuskt-compose = { module = \"org.drewcarlson:mobiuskt-compose\", version.ref = \"mobiuskt\" }\nmobiuskt-codegen = { module = \"org.drewcarlson:mobiuskt-codegen\", version.ref = \"mobiuskt\" }\nmobiuskt-codegen-api = { module = \"org.drewcarlson:mobiuskt-codegen-api\", version.ref = \"mobiuskt\" }\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>This page covers a few practical examples of Mobius.kt components. For a simple example of various components, see Getting Started.</p>"},{"location":"examples/#user-profile","title":"User Profile","text":"<p>This example demonstrates a simple Side Effect handler which makes a network request to produce data for the Model.</p>"},{"location":"examples/#model","title":"Model","text":"<pre><code>data class UserProfileModel(\n    val userId: String? = null,\n    val name: String? = null,\n    val isLoading: Boolean = false,\n    val error: String? = null\n)\n</code></pre>"},{"location":"examples/#events","title":"Events","text":"<pre><code>sealed class UserProfileEvent {\n    /**\n     * An Event to initiate loading of User data.\n     */\n    data class OnLoadUserProfile(val userId: String) : UserProfileEvent()\n\n    /**\n     * An Event modeling a successful network request for User data.\n     */\n    data class OnUserProfileLoaded(val name: String) : UserProfileEvent()\n\n    /**\n     * An Event modeling a failed network request for user data.\n     */\n    data class OnUserProfileError(val error: String) : UserProfileEvent()\n}\n</code></pre>"},{"location":"examples/#effects","title":"Effects","text":"<pre><code>sealed class UserProfileEffect {\n    /**\n     * An Effect which contains the data required to request user data from the network.\n     */\n    data class FetchUserProfile(val userId: String) : UserProfileEffect()\n}\n</code></pre>"},{"location":"examples/#update-function","title":"Update Function","text":"<p>It is recommended that you make use of code generation for sufficiently complex Update functions. For details on setting it up in your project, see Code Generation &gt; Update Generator.</p> With Code Generation <pre><code>@GenerateUpdate\nclass UserProfileUpdate : Update&lt;UserProfileModel, UserProfileEvent, UserProfileEffect&gt;, UserProfileGeneratedUpdate {\n\n    override fun onLoadUserProfile(event: UserProfileEvent.OnLoadUserProfile): Next&lt;UserProfileModel, UserProfileEffect&gt; {\n        return next(\n            model.copy(isLoading = true),\n            setOf(UserProfileEffect.FetchUserProfile(event.userId))\n        )\n    }\n\n    override fun onUserProfileLoaded(event: UserProfileEvent.OnUserProfileLoaded): Next&lt;UserProfileModel, UserProfileEffect&gt; {\n        return next(model.copy(isLoading = false, name = event.name))\n    }\n\n    override fun onUserProfileError(event: UserProfileEvent.OnUserProfileError): Next&lt;UserProfileModel, UserProfileEffect&gt; {\n        return next(model.copy(isLoading = false, error = event.error))\n    }\n}\n</code></pre> Without Code Generation (Click to expand) <pre><code>class UserProfileUpdate : Update&lt;UserProfileModel, UserProfileEvent, UserProfileEffect&gt; {\n    override fun update(model: UserProfileModel, event: UserProfileEvent): Next&lt;UserProfileModel, UserProfileEffect&gt; {\n        return when (event) {\n            is UserProfileEvent.OnLoadUserProfile -&gt; next(\n                model.copy(isLoading = true),\n                setOf(UserProfileEffect.FetchUserProfile(event.userId))\n            )\n            is UserProfileEvent.OnUserProfileLoaded -&gt; next(model.copy(isLoading = false, name = event.name))\n            is UserProfileEvent.OnUserProfileError -&gt; next(model.copy(isLoading = false, error = event.error))\n        }\n    }\n}\n</code></pre>"},{"location":"examples/#effect-handler","title":"Effect Handler","text":"<p>If your Effect Handlers are implemented in Kotlin, it is recommended that you use the Coroutines adapter. See the Coroutines module for more details.</p> With Coroutines <pre><code>fun createUserProfileHandler(\n    apiClient: ApiClient\n) = subtypeEffectHandler&lt;UserProfileEffect, UserProfileEvent&gt; {\n    addFunction&lt;UserProfileEffect.FetchUserProfile&gt; { effect -&gt;\n        when (val networkResult = apiClient.fetchUserProfile(effect.userId)) {\n            is Success -&gt; UserProfileEvent.OnUserProfileLoaded(networkResult.user.name)\n            is Failed -&gt; UserProfileEvent.OnUserProfileError(networkResult.errorMessage)\n        }\n    }\n}\n</code></pre> <p>For other advance situations, like when writing Effect Handlers in another language, you can implement Effect Handlers manually.</p> Manual, Without Coroutines (Click to expand) <pre><code>class UserProfileHandlerFactory(\n    private val apiClient: ApiClient\n) : Connection&lt;UserProfileEffect, UserProfileEvent&gt; {\n\n    override fun connect(output: Consumer&lt;UserProfileEvent&gt;) {\n        return UserProfileHandler(apiClient, output)\n    }\n}\n\nclass UserProfileHandler(\n    private val apiClient: ApiClient,\n    private val output: Consumer&lt;UserProfileEfvent&gt;\n) : Connection&lt;UserProfileEffect&gt; {\n\n    override fun accept(value: UserProfileEffect) {\n        when (value) {\n            is UserProfileEffect.FetchUserProfile -&gt; fetchUserProfile(value.userId)\n        }\n    }\n\n    override fun dispose() {\n    }\n\n    private fun fetchUserProfile(userId: String) {\n        val result = when (val networkResult = apiClient.fetchUserProfile(userId)) {\n            is Success -&gt; UserProfileEvent.OnUserProfileLoaded(networkResult.user.name)\n            is Failed -&gt; UserProfileEvent.OnUserProfileError(networkResult.errorMessage)\n        }\n        output.accept(result)\n    }\n}\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This page outlines the various Mobius.kt components in their simplest form, view the reference pages for additional details.</p>"},{"location":"getting-started/#creating-a-loop","title":"Creating a Loop","text":"<p>(See Reference &gt; Mobius Loop)</p> <p>Let's create a simple Counter to see the various Mobius.kt components. The first step in creating a loop is to define our <code>Model</code>, <code>Event</code>s, and <code>Effect</code>s.</p>"},{"location":"getting-started/#model","title":"Model","text":"<p>(See Reference &gt; Model)</p> <p>For simplicity, our Model will just be an <code>Int</code>:</p> <pre><code>typealias Model = Int\n</code></pre>"},{"location":"getting-started/#events","title":"Events","text":"<p>(See Reference &gt; Event)</p> <p>Next we need Events to update our model:</p> <pre><code>enum class Event { ADD, SUB, RESET }\n</code></pre>"},{"location":"getting-started/#effects","title":"Effects","text":"<p>(See Reference &gt; Effect)</p> <p>Effects will be covered later, so we'll just use <code>Unit</code> for now:</p> <pre><code>typealias Effect = Unit\n</code></pre>"},{"location":"getting-started/#update-function","title":"Update Function","text":"<p>(See Reference &gt; Update)</p> <p>Now that we have a model and some events to handle, let's add some counter logic in an <code>Update</code> function.</p> <pre><code>val update = Update&lt;Model, Event, Effect&gt; { model, event -&gt;\n  when (event) {\n      Event.ADD -&gt; next(model + 1)\n      Event.SUB -&gt; next((model - 1).coerceAtLeast(0))\n      Event.RESET -&gt; next(0)\n  }\n}\n</code></pre>"},{"location":"getting-started/#effect-handler","title":"Effect Handler","text":"<p>(See Reference &gt; Effect Handler)</p> <p>This example doesn't use any Effects, so we'll just define a no-op Effect Handler for now.</p> no-op effect handler (Click to expand) <pre><code>val effectHandler = Connectable&lt;Effect, Event&gt; { output -&gt;\n    object : Connection&lt;Effect&gt; {\n        override fun accept(value: Effect) = Unit\n        override fun dispose() = Unit\n    }\n}\n</code></pre>"},{"location":"getting-started/#starting-the-loop","title":"Starting the Loop","text":"<p>That's it!  We've defined everything we need to construct a <code>MobiusLoop</code>. The last thing we need is to construct a <code>MobiusLoop</code> instance with out components.</p> <p>Here are two approaches to create the <code>MobiusLoop</code>, send it events, and handle model changes.</p>"},{"location":"getting-started/#manual","title":"Manual","text":"<p>Using <code>Mobius.loop</code>, we create a <code>MobiusLoop.Factory</code> which can create a running <code>MobiusLoop</code>.</p> <pre><code>val loopFactory: MobiusLoop.Factory = Mobius.loop(update, effectHandler)\n\nval loop: MobiusLoop = loopFactory.startFrom(0)\n</code></pre> <p>This is the simplest form of a <code>MobiusLoop</code>, it only has two states: <code>running</code> and <code>disposed</code>.</p> Manual Loop Example <pre><code>// Attach an Observer to handle model updates\nval observerRef: Disposable = loop.observer { model -&gt;\n   println(\"Model: $model\")\n}\n\n// Send some events to our loop\nloop.dispatchEvent(Event.ADD)   // Model: 1\nloop.dispatchEvent(Event.ADD)   // Model: 2\nloop.dispatchEvent(Event.SUB)   // Model: 1\nloop.dispatchEvent(Event.RESET) // Model: 0\nloop.dispatchEvent(Event.SUB)   // Model: 0\n\n// Cleanup our resources\nloop.dispose()\n</code></pre>"},{"location":"getting-started/#controller","title":"Controller","text":"<p>Alternatively a loop can be managed with a <code>MobiusLoop.Controller</code>, giving the loop a flexible lifecycle. This example includes some imaginary UI details for demonstration, this could apply to Android UI, iOS UIKit, or any other UI framework.</p> Loop Controller Example <pre><code>// Create a controller that lives of our UI container\nval loopController = Mobius.controller(loopFactory, 0)\n\n// When our UI container is created, connect our buttons and outputs\nloopController.connect { output -&gt;\n    buttonAdd.onClick { output.accept(Event.ADD) }\n    buttonSub.onClick { output.accept(Event.SUB) }\n    buttonReset.onClick { output.accept(Event.RESET) }\n\n    object : Consumer&lt;Model&gt; {\n        override fun accept(value: Model) {\n            counterLabel.text = value.toString()\n        }\n\n        override fun dispose() {\n            buttonAdd.removeOnClick()\n            buttonSub.removeOnClick()\n            buttonReset.removeOnClick()\n        }\n    }\n}\n\n// When the UI is presented: start the loop\nloopController.start()\n\n// When we click our buttons, the counterLabel will be updated with the new model\n\n// When the UI is no longer presented: Stop the loop to prevent UI updates or events\nloopController.stop()\n\n// Loop could be started with `loopController.start()` when the UI is presented again\n\n// When the UI is destroyed: Dispose the loop and release references to UI elements\nloopController.disconnect()\n</code></pre>"},{"location":"logging-and-error-handling/","title":"Logging and Error Handling","text":""},{"location":"logging-and-error-handling/#logging","title":"Logging","text":"<p><code>MobiusLoop</code> logging is handled by the <code>MobiusLoop.Logger</code> provided to the <code>MobiusLoop.Builder</code>. Mobius.kt also has some internal logging which is handled by <code>MobiusHooks.InternalLogger</code>.</p> <p>The default <code>InternalLogger</code> is backed by <code>println</code> for broad platform support. A custom <code>InternalLogger</code> implementation can be provided by setting a logger factory:</p> <pre><code>MobiusHooks.setLoggerFactory { tag: String -&gt;\n    CustomInternalLogger(tag)\n}\n</code></pre>"},{"location":"logging-and-error-handling/#error-handling","title":"Error Handling","text":"<p>Mobius.kt attempts to expose programmer errors as <code>RuntimeException</code>s resulting in a crash. Because uncaught exceptions in background <code>Threads</code>/<code>Workers</code> are handled by the specific instance, they are logged as an Error and ignored by Mobius.kt.</p> <p>You can override the default error handling behavior with <code>MobiusHooks.setErrorHandler</code>:</p> <pre><code>MobiusHooks.setErrorHandler { error: Throwable -&gt;\n    MyCrashReportingService.logException(error)\n    error.printStackTrace()\n}\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":"<p>The following is an unordered list of tasks that may be addressed in the future:</p> <ul> <li>Demo project covering SwiftUI, Compose, and Web (WIP)</li> <li>Demo project covering UIKit and Legacy Android View system</li> <li>Improve general performance of event dispatching and processing</li> <li>RxJava2 adapters</li> <li>RxJava3 adapters</li> <li>New nested loop APIs with simplified usage</li> <li>First class UIKit adapters</li> <li>First class SwiftUI adapters</li> <li>Change group id (<code>org.drewcarlson</code>) to something else</li> </ul>"},{"location":"useful-libraries/","title":"Useful Libraries","text":"<p>This page contains a list of useful libraries which can be useful in larger projects using Mobius.kt.</p>"},{"location":"useful-libraries/#kopykat","title":"kopykat","text":"<p>When writing <code>Update</code> functions you will typically use the <code>copy</code> method provided by <code>data class</code>es to create updated model instances.  The standard <code>copy</code> method is adequate in simple cases but can quickly clutter your <code>Update</code> functions.  Kopykat provides generated builder <code>copy</code> methods which provide instance variables to set instead of a long list of function parameters.</p>"},{"location":"useful-libraries/#redacted-compiler-plugin","title":"redacted-compiler-plugin","text":"<p><code>data class</code>es provide a <code>toString</code> in Model classes which make Logging simple and useful in Mobius.kt. When Model's contain sensitive information you do not want logged, overriding and keeping the <code>toString</code> method updated is tedious.  With Redacted, you can annotate individual properties with <code>@Redacted</code> to omit the actual data from the standard <code>toString</code> implementation.</p>"},{"location":"useful-libraries/#poko","title":"Poko","text":"<p><code>data class</code>es are a convenient utility in a lot of situations, especially with Mobius.kt. But there may be cases where they may be generating a lot of code that you do not use. If you're not using dead-code elimination tools, this can bloat your application or library. Poko allows you to get the <code>toString</code>, <code>equals</code>, and <code>hashCode</code> implementations provided by <code>data class</code> without generated <code>copy</code> methods. This can be particularly useful with <code>Event</code> and <code>Effect</code> class subtypes.</p>"},{"location":"development/documentation/","title":"Documentation","text":"<p>Documentation is created with MkDocs using Material for MkDocs. MkDocs is configured with <code>mkdocs.yml</code> and documentation source is stored in the <code>docs</code> folder.</p>"},{"location":"development/documentation/#install-python","title":"Install Python","text":"<p>Download and install the latest version of Python.</p> macOS Windows"},{"location":"development/documentation/#macos","title":"macOS","text":"<p>Using Homebrew</p> <pre><code>brew install python\n</code></pre>"},{"location":"development/documentation/#windows","title":"Windows","text":"<p>Download and install the recommended version from python.org.</p> <p>Or with Chocolatey</p> <pre><code>choco install python\n</code></pre>"},{"location":"development/documentation/#install-mkdocs-and-plugins","title":"Install MkDocs and plugins","text":"<p>Open a new Terminal or Command Prompt window.</p> <pre><code>pip install mkdocs mkdocs-material mkdocs-markdownextradata-plugin\n</code></pre> <p>For more information see the MkDocs Installation Guide and the Material for MkDocs Installation Guide.</p>"},{"location":"development/documentation/#writing-documentation","title":"Writing Documentation","text":"<p>Documentation source files are written in Markdown. For navigation and advanced formatting features, see the MkDocs Writing your docs guide and Material for MkDocs Reference.</p> Variables <p>Some dynamic variables are made available, they can be used with the <code>{{ name }}</code> syntax. Below are the available variables.</p> Name Value project The project name for the repository lib_version The current release version, for example <code>2.3.5</code> (No <code>v</code> prefix)"},{"location":"development/documentation/#view-docs-locally","title":"View docs locally","text":"<p>To view the docs locally, open a terminal or command prompt and cd into your <code>Mobius.kt</code> folder then run</p> <pre><code>mkdocs serve\n</code></pre> <p>Your changes will be served at http://127.0.0.1:8000. After saving changes, the webpage will reload automatically.</p>"},{"location":"development/documentation/#deployment","title":"Deployment","text":"<p>Changes are deployed automatically for tagged releases.</p>"},{"location":"modules/codegen/","title":"Code Generation","text":""},{"location":"modules/codegen/#update-generator","title":"Update Generator","text":"<p>A common pain point with Mobius.kt is wrapping Event types to their state change functions. In Mobius.kt this code is implemented in your <code>Update</code> function, taking an event and returning a <code>Next</code> instance.</p> <p>Using KSP, <code>mobiuskt-codegen</code> provides code generation to reduce manual boilerplate when writing complex <code>Update</code> functions.</p> <p>Given a <code>sealed class Event</code> declaration, an interface is generated defining update methods for each <code>Event</code> subclass and the exhaustive <code>when</code> block in the <code>update</code> method.</p>"},{"location":"modules/codegen/#example","title":"Example","text":"<p>To apply code generation, add the <code>@GenerateUpdate</code> annotation to your Update function class definition:</p> <pre><code>@GenerateUpdate\nclass TestUpdate : Update&lt;TestModel, TestEvent, TestEffect&gt;, TestGeneratedUpdate {\n  // ...\n}\n</code></pre> Loop components (Click to expand) <pre><code>data class TestModel(\n    val counter: Int,\n)\n\nsealed class TestEvent {\n    data object Increment : TestEvent()\n    data object Decrement : TestEvent()\n    data class SetValue(val newCounter: Int) : TestEvent()\n}\n\nsealed class TestEffect\n</code></pre> Generated output <pre><code>interface TestGeneratedUpdate : Update&lt;TestModel, TestEvent, TestEffect&gt; {\n    override fun update(model: TestModel, event: TestEvent): Next&lt;TestModel, TestEffect&gt; {\n        return when (event) {\n            TestEvent.Increment -&gt; increment(model)\n            TestEvent.Decrement -&gt; decrement(model)\n            is TestEvent.SetValue -&gt; setValue(model, event)\n        }\n    }\n\n    fun increment(model: TestModel): Next&lt;TestModel, TestEffect&gt;\n\n    fun decrement(model: TestModel): Next&lt;TestModel, TestEffect&gt;\n\n    fun setValue(model: TestModel, event: TestEvent.SetValue): Next&lt;TestModel, TestEffect&gt;\n}\n</code></pre>"},{"location":"modules/codegen/#nested-sealed-classes","title":"Nested sealed classes","text":"<p>By default, nested sealed Events will produce a function for each subtype.</p> Child Sealed Class Default Behavior <pre><code>sealed class Event {\n    // ...\n    sealed class Result : Event() {\n        data class Success(val data: String) : Result()\n        data class Error(val message: String) : Result()\n    }\n}\n</code></pre> <pre><code>fun resultSuccess(event: Event.Result.Success): Next&lt;Model, Effect&gt; {\n    // ...\n}\n\nfun resultError(event: Event.Result.Error): Next&lt;Model, Effect&gt; {\n    // ...\n}\n</code></pre> <p>This behavior can be changed with <code>@DisableSubtypeSpec</code>, causing the sealed class to be handled by one function.</p> Child Sealed Class Default Behavior <pre><code>sealed class Event {\n    @DisableSubtypeSpec\n    sealed class Result : Event() {\n        // ...\n</code></pre> <pre><code>fun result(event: Event.Result): Next&lt;Model, Effect&gt; {\n    // ...\n}\n</code></pre>"},{"location":"modules/codegen/#gradle-configuration","title":"Gradle Configuration","text":"<p>Use the following kts gradle configuration to apply the Update generator in your project:</p> Kotlin Gradle Script - JVM/Android (Click to expand) <pre><code>plugins {\n    kotlin(\"jvm\") // or kotlin(\"android\")\n    id(\"com.google.devtools.ksp\") version \"&lt;KSP-Version&gt;\"\n}\n\nkotlin {\n    sourceSets.main {\n        kotlin.srcDir(\"build/generated/ksp/$name/kotlin\")\n    }\n}\n\ndependencies {\n    implementation(\"org.drewcarlson:mobiuskt-codegen-api:$mobiuskt_version\")\n    ksp(\"org.drewcarlson:mobiuskt-codegen:$mobiuskt_version\")\n}\n</code></pre> Kotlin Gradle Script - Multiplatform <pre><code>plugins {\n    kotlin(\"multiplatform\")\n    id(\"com.google.devtools.ksp\") version \"&lt;KSP-Version&gt;\"\n}\n\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            kotlin.srcDir(\"build/generated/ksp/$name/kotlin\")\n            dependencies {\n                implementation(\"org.drewcarlson:mobiuskt-codegen-api:$mobiuskt_version\")\n            }\n        }\n    }\n}\n\n// Note this must be in a top-level `dependencies` block, not `kotlin { sourceSets { .. } }`\ndependencies {\n    add(\"kspCommonMainMetadata\", \"org.drewcarlson:mobiuskt-codegen:$mobiuskt_version\")\n}\n\n// This ensures that when compiling for any target, your `commonMain` sources are\n// scanned and code is generated to `build/generated/ksp/commonMain` instead of a\n// directory for the specific target. See https://github.com/google/ksp/issues/567\nif (tasks.any { it.name == \"kspCommonMainKotlinMetadata\" }) {\n    tasks.withType&lt;org.jetbrains.kotlin.gradle.dsl.KotlinCompile&lt;*&gt;&gt;().all {\n        if (name != \"kspCommonMainKotlinMetadata\") {\n            dependsOn(\"kspCommonMainKotlinMetadata\")\n        }\n    }\n}\n</code></pre> <p>For more details see the official KSP documentation.</p>"},{"location":"modules/compose/","title":"Compose","text":"<p>The <code>mobiuskt-compose</code> module provides support for Compose Multiplatform and Jetpack Compose with built in support for Jetpack Navigation Component</p> <p>Note: This module is experimental and likely to change in the future.</p>"},{"location":"modules/compose/#creating-a-loop","title":"Creating a Loop","text":"<p>With Compose, loops are created with <code>rememberMobiusLoop</code>.</p> <pre><code>@Composable\nfun MyScreenRoute() {\n    val (modelState, eventConsumer) = rememberMobiusLoop(ScreenModel()) {\n        Mobius.loop(MyScreenUpdate(), MyScreenHandler())\n            .logger(SimpleLogger(\"MyScreen\"))\n    }\n\n    MyScreen(\n        model = modelState.value,\n        eventConsumer = eventConsumer,\n    )\n}\n\n@Composable\nfun MyScreen(\n    model: ScreenModel,\n    modifier: Modifier = Modifier,\n    eventConsumer: (ScreenEvent) -&gt; Unit\n) {\n    Column(modifier = modifier) {\n        Text(model.labelTest)\n\n        Button(\n            onClick = { eventConsumer(ScreenEvent.OnClick) }\n        ) {\n            Text(\"Button\")\n        }\n    }\n}\n</code></pre>"},{"location":"modules/compose/#platform-behavior","title":"Platform Behavior","text":""},{"location":"modules/compose/#iosdesktopweb","title":"iOS/Desktop/Web","text":"<p>For these platforms, the loop is running while in the Composition and is disposed when removed. The <code>rememberMobiusLoopLocal</code> method is available if you need to enforce this behavior on all platforms.</p>"},{"location":"modules/compose/#android","title":"Android","text":"<p>When using Jetpack Navigation Component, the loop will be scoped to the route and survive configuration changes.</p> <p>Without Jetpack Navigation, <code>rememberMobiusLoop</code> uses <code>rememberMobiusLoopLocal</code> meaning the loop will be disposed and recreated on configuration changes.</p> Supporting other Navigation libraries (Control the loop's lifecycle) <p>To support different navigation libraries, you must provide a custom <code>ViewModelStoreOwner</code> that is tied to the libraries route lifecycle.</p> <p><code>rememberMobiusLoop</code> checks if <code>LocalViewModelStoreOwner.current</code> is set to an Activity, in which case <code>rememberMobiusLoopLocal</code> is used. When it's not an Activity, we're likely within a route for Jetpack Navigation or some other library so the loop will be held in a ViewModel which has it's lifecyle managed by the store owner.</p> <pre><code>val navLibraryViewModelStoreOwner = ...\nCompositionLocalProvider(\n    LocalViewModelStoreOwner provides navLibraryViewModelStoreOwner\n) {\n    route(path = \"my-screen\") {\n        val (modelState, eventConsumer) = rememberMobiusLoop(ScreenModel()) {\n            Mobius.loop(MyScreenUpdate(), MyScreenHandler())\n                .logger(SimpleLogger(\"MyScreen\"))\n        }\n        MyScreen(\n            model = modelState.value,\n            eventConsumer = eventConsumer,\n        )\n    }\n}\n</code></pre>"},{"location":"modules/coroutines/","title":"Coroutines","text":"<p>Coroutines and Flows are supported with the <code>mobiuskt-coroutines</code> module (See Download).</p> <p>Note: <code>Update</code> functions are always synchronous and there is no use for coroutines in them.</p>"},{"location":"modules/coroutines/#side-effects","title":"Side Effects","text":"<p>The <code>subtypeEffectHandler</code> builder provides various coroutine based methods to handle Effects in whatever way your application requires.</p> <pre><code>val effectHandler = subtypeEffectHandler&lt;Effect, Event&gt; {\n\n    // suspend () -&gt; Unit\n    addAction&lt;Effect.SubType1&gt; {\n        // Perform action without Effect data and without a result.\n    }\n\n    // suspend (Effect) -&gt; Unit\n    addConsumer&lt;Effect.SubType2&gt; { effect -&gt;\n        // Perform action with Effect data and without a result.\n    }\n\n    // suspend (Effect) -&gt; Event\n    addFunction&lt;Effect.SubType3&gt; { effect -&gt;\n        // Perform action with Effect data and with a result.\n        Event.Result()\n    }\n\n    // FlowCollector&lt;Event&gt;.(Effect) -&gt; Unit\n    addValueCollector&lt;Effect.SubType4&gt; { effect -&gt;\n        // Perform action with Effect data and `FlowCollector` body\n        // Useful for tasks with multiple result events.\n        emit(Event.Result())\n        emitAll(createEventFlow())\n    }\n\n    // (Flow&lt;Effect&gt;) -&gt; Flow&lt;Event&gt;\n    addTransformer&lt;Effect.SubType6&gt; { effects -&gt;\n        // This allows freeform Flow operator usage for more advanced cases.\n        effects.map { effect -&gt; Event.Result() }\n    }\n}\n</code></pre>"},{"location":"modules/coroutines/#creating-the-loop","title":"Creating the Loop","text":"<p>A <code>SubtypeEffectHandler</code> can be used directly with the <code>FlowMobius</code> loop factory</p> <pre><code>val loopFactory = FlowMobius.loop(update, effectHandler)\n</code></pre> <p>Or with the standard <code>Mobius</code>/<code>MobiusLoop</code> builders with the <code>asConnectable()</code> extension</p> <pre><code>val loopFactory = Mobius.loop(update, effectHandler.asConnectable())\n</code></pre>"},{"location":"modules/coroutines/#execution-policy","title":"Execution Policy","text":"<p>Execution of functions added to a <code>SubtypeEffectHandler</code> can be configured with an <code>ExecutionPolicy</code>.</p> <ul> <li> <p><code>ExecutionPolicy.Sequential</code>: The handler is executed with each Effect in order one at a   time, waiting until the previous execution is complete before starting another.</p> </li> <li> <p><code>ExecutionPolicy.Latest</code>: Each Effect will execute the handler, new Effects will cancel the   previous handler if it has not finished executing.</p> </li> <li> <p>(Default) <code>ExecutionPolicy.Concurrent</code>: Effects will be processed concurrently up to the maximum provided   concurrency limit.   The default limit is defined   by <code>DEFAULT_CONCURRENCY</code>   from the coroutines library.</p> </li> </ul> <p>An <code>ExecutionPolicy</code> can be applied in two ways:</p> <pre><code>// Set the default policy for all handlers\nsubtypeEffectHandler&lt;Effect, Event&gt;(ExecutionPolicy.Sequential) {\n\n    // Override the default per handler function\n    addConsumer&lt;Effect.MyEffect&gt;(ExecutionPolicy.Latest) {\n        // ...\n    }\n}\n</code></pre>"},{"location":"modules/extras/","title":"Extras","text":"<p>The extras module provides various flexible utilities for composing Mobius loops in a way that fits your project.</p>"},{"location":"modules/extras/#compositelogger","title":"CompositeLogger","text":"<p>Multiple <code>MobiusLoop.Logger</code> instances can be combined with a <code>CompositeLogger</code>.</p> <pre><code>val myLogger = CompositeLogger.from(\n    MyLoggingBackendLogger(\"MyScreen\"),\n    SimpleLogger(\"MyScreen\")\n)\n\nval loop = Mobius.loop(MyUpdate(), effectHandler)\n    .logger(myLogger)\n    .startFrom(MyModel())\n</code></pre>"},{"location":"modules/extras/#effect-handler-decorators","title":"Effect Handler Decorators","text":""},{"location":"modules/extras/#compositeeffecthandler","title":"CompositeEffectHandler","text":"<p><code>CompositeEffectHandler</code> delegates to a provided list of Effect handlers. This can be useful for reusing handlers with multiple loops, and keeping handlers small and focused.</p> <pre><code>val effectHandler = CompositeEffectHandler.from(\n    Connectable { output -&gt; AnalyticsHandler(output) },\n    Connectable { output -&gt; UserStateHandler(output) },\n    Connectable { output -&gt; MyScreenHandler(output) }\n)\n\nval loop = Mobius.loop(MyScreenUpdate(), effectHandler)\n    .startFrom(MyScreenModel())\n</code></pre>"},{"location":"modules/extras/#mappedeffecthandler","title":"MappedEffectHandler","text":"<p><code>MappedEffectHandler</code> allows you to transform in the Effect inputs and Event outputs to fit your loop.</p> <pre><code>val myScreenUserStateHandler = Connectable { output -&gt; UserStateHandler(output) }\n    .mapped(\n        mapEffect = { effect: MyScreenEffect -&gt;\n            when (effect) {\n                MyScreenEffect.Logout -&gt; UserStateEffect.Logout\n                MyScreenEffect.RefreshUserState -&gt; UserStateEffect.Refresh\n                else -&gt; null // Ignore the effect\n            }\n        },\n        mapEvent = { event: UserStateEvent -&gt;\n            when (event) {\n                UserStateEvent.LoggedOut -&gt; MyScreenEvent.LoggedOut\n                is UserStateEvent.UserUpdated -&gt; MyScreenEvent.UserUpdated(event.user)\n                else -&gt; null // Ignore the event\n            }\n        }\n    )\nval effectHandler = CompositeEffectHandler.from(\n    myScreenUserStateHandler,\n    Connectable { output -&gt; MyScreenHandler(output) }\n)\n</code></pre>"},{"location":"modules/testing/","title":"Testing","text":"<p>The <code>mobiuskt-test</code> module provides a DSL for behavior driven tests and a light re-implementation of Hamcrest style APIs to test mobius loops (See Download).</p> Behavior testing DSL Example <pre><code>@Test\nfun testAddEvent() {\n    UpdateSpec(update)\n        .given(0) // given model of 0\n        .whenEvent(Event.ADD) // when Event.Add occurs\n        .then(assertThatNext(hasModel())) // assert the Next object contains any model\n    // No AssertionError, test passed.\n}\n\n@Test\nfun testAddEventError() {\n    UpdateSpec(update)\n        .given(0)\n        .whenEvent(Event.ADD)\n        .then(assertThatNext(hasModel(-1)))\n    // AssertionError: expected -1 but received 1, test failed.\n}\n</code></pre> <p>For more details on the available matchers, see the API documentation.</p>"},{"location":"patterns/events-and-effects/","title":"Defining Events and Effects","text":"<p>Event and Effect objects are very similar. They play distinct roles within a Mobius loop, yet both are immutable data objects used as messages. Due to this, events and effects are commonly created using the same pattern. In this document, we collectively refer to them as \"messages.\"</p>"},{"location":"patterns/events-and-effects/#different-ways-to-define-messages","title":"Different ways to define messages","text":"<p>Message types are opaque to Mobius.kt, so you are responsible for defining what they are and their meaning. The only constraint is that all message kind instances must have a single type they implement. So all Events for a specific loop share a type, and all Effects share a type.</p> <p>Messages can be defined in multiple ways:</p>"},{"location":"patterns/events-and-effects/#enumerations","title":"Enumerations","text":"<p>The most basic kind of message is an <code>enum</code>, <code>Int</code>, or possibly a <code>String</code>. Such messages cannot hold any additional data, so this is the most limited approach suitable only for simple loops. This type of message is used mostly for documentation and internal testing.</p>"},{"location":"patterns/events-and-effects/#tagged-object","title":"Tagged object","text":"<p>Building on enumerations, tagged objects could be a simple data model with a <code>tag</code> field defining the message type, indicating what fields should be read.</p> <p>You might also have a <code>Map&lt;String, String&gt;</code> holding data, each message may contain a different set of keys and values. This is a valid approach and can simplify certain use-cases, but it lacks type-safety. You must ensure you're creating maps with the correct data, and only reading the correct data when available.</p>"},{"location":"patterns/events-and-effects/#subclasses","title":"Subclasses","text":"<p>This is the recommended approach for defining messages. Each message has a common parent type, like an interface <code>MyEvent</code>, which each Event type would implement. The individual subclasses can then include their own specific data.</p>"},{"location":"patterns/events-and-effects/#kotlin-sealed-classes","title":"Kotlin Sealed Classes","text":"<p>With Kotlin, sealed classes greatly simplify creating message structures. They allow tying all the sub messages together like an <code>enum</code>, but allowing for instances with custom data.</p> <pre><code>sealed class MyEvent {\n    data class Text(val text: String) : MyEvent()\n    data class Number(val number: Int) : MyEvent()\n    data object Reset : MyEvent()\n}\n</code></pre> <p>Use <code>data object</code> when necessary</p> <p>If the message type does not contain custom data, <code>data object</code> should be used instead of <code>data class</code>.</p> <p>Now your Update function can use a <code>switch</code> statement to handle all message types:</p> <pre><code>when (event) {\n    is Text -&gt; event.text\n    is Number -&gt; event.number\n    Reset -&gt; /* code */\n}\n</code></pre> <p>Avoid using <code>else -&gt;</code> branches</p> <p>When possible, avoid using an <code>else -&gt;</code> branch to ensure all message types are handled when defining new ones.</p>"},{"location":"patterns/immutability/","title":"Immutability","text":"<p>Mobius.kt requires most objects to be immutable, including the Model, Event, and Effect objects. Without this constraint Mobius does not work.</p> <p>An object is immutable if it and all objects it refers to do not have mutable fields. Mutable fields are only safe if they do not change during the objects existence.</p> <p>Beware of arrays</p> <p>Arrays are mutable so having a <code>val myarray: Array&lt;Int&gt;</code> or <code>final Array&lt;Int&gt; myArray = ...</code> only applies to the field and not the array values.</p> <p>For data structures, ensure you're using an <code>Immutable</code> variant or create a copy from the original source. For example, prefer <code>ImmutableList</code> from kotlinx.collections.immutable over the standard <code>List</code> type. If that is not possible, use <code>myList.toList()</code> to create a copy before storing the list in an object.</p>"},{"location":"patterns/models/","title":"Defining Models","text":"<p>Like Events and Effects, Models are opaque to Mobius. The only requirement is that they are immutable.</p> <p>Since the Update function represents state transitions in a state machine, where the model represents the current state of the machine. When defining the model of a state machine, there are many options for defining it between a finite-state machine and a less strict object containing a number of fields that encapsulate state.</p>"},{"location":"patterns/models/#all-states-use-different-classes","title":"All states use different classes","text":"<p>In the finite-state machine approach, one class per state means the machine can only be in one state at a time. This means each state would only hold data needed for that state.</p> <pre><code>sealed class Model {\n    data object WaitingForData : Model()\n    data class Loaded(val data: String) : Model()\n    data class Error(val message: String) : Model()\n}\n</code></pre> <p>At any given moment, the model can only be one of the three <code>WaitingForData</code>, <code>Loaded</code>, and <code>Error</code> classes. This approach is great for small loops with a few states, or to ensure all edge cases are handled.</p> <p>This approach has a few drawbacks, particularly when there are a lot of states with overlapping data. For example, when maintaining an \"offline\" state, you may need to differentiate offline-without-data from offline-with-data. You'll find this results in a large number of individual states that require their own transitions to be defined.</p>"},{"location":"patterns/models/#all-states-use-the-same-class","title":"All states use the same class","text":"<p>This approach is less strict in terms of a state machine, with all data being stored in top-level fields of the model.</p> <pre><code>data class Model(\n    val loaded: Boolean,\n    val error: Boolean,\n    val offline: Boolean,\n    val data: String?,\n    val errorMessage: String?,\n)\n</code></pre> <p>Warning</p> <p>With this approach you're likely to end up with a lot of <code>null</code> fields. The could also be invalid combinations of fields for example if both <code>loaded</code> and <code>error</code> are true, or both the <code>data</code> and <code>errorMessage</code> are populated. Be careful when using this approach as you must properly consider various cases of different field states.</p> <p>It is generally best to start with this approach when defining model as it is easy to evolve with new requirements.</p>"},{"location":"patterns/models/#hybrid-approach","title":"Hybrid approach","text":"<p>By combining both previous approaches, we can get the best of both worlds: clear separation of data available in a given state, and reduced effort when evolving the model.</p> <pre><code>sealed class LoadingState {\n    data object WaitingForData : LoadingState()\n    data class Loaded(val data: String) : LoadingState()\n    data class Error(val message: String) : LoadingState()\n}\n\ndata class Model(\n    val offline: Boolean,\n    val loading: LoadingState,\n)\n</code></pre> <p>In this example we can have both the <code>Loaded</code> data and be <code>offline</code> at the same time. This provides a scalable foundation for more complex loop behaviors while remaining easy to reason about.</p>"},{"location":"patterns/models/#some-useful-tricks-for-model-objects","title":"Some useful tricks for model objects","text":"<p>Use <code>data class</code> for Models</p> <p>Kotlin data classes provide useful utilities for Immutable objects. Perhaps the most important is the generated <code>copy(...)</code> method, allowing you to create a new instance with only specified fields changed.</p> <pre><code>data class Task(val description: String, val complete: Boolean)\n\nval task1 = Task(\"hello\", false)\nval task2 = task1.copy(complete = true)\n</code></pre> <p>Use <code>with</code>-methods to manage copy complexity</p> <p>For certain data classes, some usages of <code>copy</code> may become large and difficult to comprehend quickly. In these cases it is helpful to add specialized <code>with</code> functions to produce new model instances.</p> <pre><code>data class Model(\n    val filter: Filter,\n    val tasks: List&lt;Task&gt;,\n) {\n\n    fun withCompletedTask(completedTask: Task): Model {\n        val newTasks = tasks.toMutableList()\n        val taskIndex = newTasks.indexOf(completedTask)\n        newTasks[taskIndex] = newTask[taskIndex].copy(completed = true)\n        return copy(tasks = newTasks.toList())\n    }\n}\n</code></pre>"},{"location":"patterns/pure-vs-impure-functions/","title":"Pure vs Impure Functions","text":"<p>A pure function is a function that has a return value determined entirely by the input parameters, and does not have any side-effects.</p> <p>Functions that do not meet these requirements are called 'impure'.</p>"},{"location":"patterns/pure-vs-impure-functions/#pure-functions-are-fundamentally-simple","title":"Pure functions are fundamentally simple","text":"<p>Because Pure functions are deterministic they are easy to understand, and makes issues easy to fix. They are easy to use as building blocks when creating complex business logic.</p>"},{"location":"patterns/pure-vs-impure-functions/#pure-functions-are-extremely-easy-to-test","title":"Pure functions are extremely easy to test","text":"<p>It is much easier to write an exhaustive test suite covering all input parameters that reach different branches.</p>"},{"location":"patterns/pure-vs-impure-functions/#impure-functions-are-complex-with-internal-state","title":"Impure functions are complex with internal state","text":"<p>Unlike Pure functions, Impure functions are harder to follow and test because they use external state and behavior that affects the result of the function.</p>"},{"location":"patterns/pure-vs-impure-functions/#more-about-pure-functions","title":"More about Pure functions","text":"<p>For more information on benefits of pure functions, see https://alvinalexander.com/scala/fp-book/benefits-of-pure-functions/.</p>"},{"location":"platforms/android/","title":"Android","text":"<p>Mobius.kt provides a few different Android specific utilities for Logging and binding to Android UI.</p> <p>See the Modules &gt; Compose section for Jetpack Compose/Compose Multiplatform documentation.</p>"},{"location":"platforms/android/#mobiuscontroller","title":"MobiusController","text":"<p>(See Android ViewModel below for a less manual approach to UI lifecycle binding.)</p> <p><code>MobiusLoop.Controller</code>s are a useful construct for binding a <code>MobiusLoop</code> to platform specific UI lifecycles. The <code>MobiusLoop.Controller</code> wraps a <code>MobiusLoop</code> so that it can be started/stopped and paused/resumed based on lifecycle events. It can easily be bound to a <code>Activity</code>, <code>Fragment</code>, <code>View</code> or similar custom container.</p> <pre><code>// Create a LoopFactory as normal\nval defaultModel = Model()\nval loopFactory =\n    Mobius.loop(update, effectHandler)\n        .init(initFunc)\n        .logger(AndroidLogger.tag(\"My Loop\"))\n\n\nval controller = MobiusAndroid.controller(loopFactory, defaultModel)\n</code></pre> <p>Now you have a <code>MobiusLoop.Controller</code> which can be bound to your desired UI abstraction. The important detail in <code>MobiusAndroid.controller</code> is that model update handling is bound to the main thread.</p> <p>See Getting Started &gt; Starting the Loop &gt; Controller and WorkRunners for more details.</p>"},{"location":"platforms/android/#viewmodel","title":"ViewModel","text":"<p>To simplify lifecycle concerns with the standard Jetpack library approach, <code>MobiusLoopViewModel</code> is provided to wrap a <code>MobiusLoop</code> instance inside a <code>ViewModel</code>. This brings the lifecycle handling of your <code>MobiusLoop</code> directly inline with a standard <code>ViewModel</code> implementation.</p> <pre><code>val viewModel = MobiusLoopViewModel.create({ _, _ -&gt;\n    Mobius.loop(update, effectHandler)\n        .init(initFunc)\n}, defaultModel)\n\n// Get the current model\nviewModel.model\n\n// Get a LiveData&lt;Model&gt;\nviewModel.models\n\n// Dispatch events to the loop\nviewModel.dispatchEvent(Event())\n</code></pre>"},{"location":"platforms/android/#androidlogger","title":"AndroidLogger","text":"<p>For Android, you'll likely want to log messages to Logcat. The <code>AndroidLogger</code> implementation of <code>MobiusLoop.Logger</code> can be used as follows.</p> <pre><code>val logger = AndroidLogger.tag(\"My Loop\")\nval loopFactory =\n    Mobius.loop(update, effectHandler)\n        .init(initFunc)\n        .logger(logger)\n</code></pre>"},{"location":"platforms/android/#workrunners","title":"WorkRunners","text":"<p>Two Android specific <code>WorkRunner</code> implementations are provided: <code>LooperWorkRunner</code> and <code>MainThreadWorkRunner</code>. Additionally, Android targets have access to the standard Jvm <code>WorkRunner</code>s (see Jvm &gt; WorkRunners).</p>"},{"location":"platforms/android/#mainthreadworkrunner","title":"MainThreadWorkRunner","text":"<p>As the name implies, <code>MainThreadWorkRunner</code> allows you to execute work on Android's Main Thread. This is particularly useful for handling Model updates on the Main Thread in order to update UI elements.</p> <pre><code>val workRunner = MainThreadWorkRunner.create()\n</code></pre> <p>Note that when using <code>MobiusLoopViewModel</code> or <code>MobiusAndroid.controller</code>, you will not need to manually create a <code>MainThreadWorkRunner</code>.</p>"},{"location":"platforms/android/#looperworkrunner","title":"LooperWorkRunner","text":"<p><code>LooperWorkRunner</code> enables dispatching work to a provided <code>Looper</code>. This is primarily used to facilitate the <code>MainTHreadWorkRunner</code>, but if needed any <code>Looper</code> can be provided.</p> <pre><code>val handlerThread = HandlerThread(\"MyThread\")\nhandlerThread.start()\n\nval workRunner = LooperWorkRunner.using(handlerThread.looper)\n</code></pre>"},{"location":"platforms/javascript/","title":"Javascript","text":""},{"location":"platforms/javascript/#workrunners","title":"WorkRunners","text":"<p>For Javascript targets the <code>AsyncWorkRunner</code> backed by <code>setTimeout(work, 0)</code> is provided.</p> <pre><code>val workRunner = WorkRunners.async()\n</code></pre>"},{"location":"platforms/jvm/","title":"Jvm","text":""},{"location":"platforms/jvm/#workrunners","title":"WorkRunners","text":"<p>Various factories are provided for <code>java.util.concurrent.ExecutorService</code>.</p>"},{"location":"platforms/jvm/#single-thread","title":"Single Thread","text":"<pre><code>val workRunner = WorkRunners.singleThread()\n</code></pre>"},{"location":"platforms/jvm/#fixed-thread-pool","title":"Fixed Thread Pool","text":"<pre><code>val workRunner = WorkRunners.fixedThreadPool(n = 2)\n</code></pre>"},{"location":"platforms/jvm/#cached-thread-pool","title":"Cached Thread Pool","text":"<pre><code>val workRunner = WorkRunners.cachedThreadPool()\n</code></pre>"},{"location":"platforms/jvm/#existing-executorservice","title":"Existing ExecutorService","text":"<p>If you have an existing <code>ExecutorService</code>, you can wrap it with <code>WorkRunners.from(service)</code></p> <pre><code>val myExecutor = Executors.newSingleThreadExecutor()\nval workRunner = WorkRunners.from(myExecutor)\n</code></pre>"},{"location":"platforms/native/","title":"Native","text":""},{"location":"platforms/native/#workrunners","title":"WorkRunners","text":""},{"location":"platforms/native/#common-native","title":"Common Native","text":"<p>For all native targets, there are <code>WorkRunner</code> implementations backed by Kotlin's Worker APIs.</p> <pre><code>// Create a WorkRunner backed by a new Worker instance\nval workRunner = WorkRunners.nativeWorker()\n\n// Optional: Provide details for the new Worker instance\nval workRunner = WorkRunners.nativeWorker(\n    name = \"Worker-1\",\n    errorReporting = true,\n)\n\n// Alternatively, use an existing Worker Instance\nval workRunner = WorkRunners.nativeWorker(myWorkerInstance)\n</code></pre>"},{"location":"platforms/native/#apple","title":"Apple","text":"<p>For Apple targets, the <code>DispatchQueueWorkRunner</code> backed by <code>dispatch_queue</code> is available.</p> <pre><code>val globalWorkRunner = DispatchQueueWorkRunner.global()\n\nval mainWorkRunner = DispatchQueueWorkRunner.main()\n\nval customWorkRuner = WorkRunners.fromDispatchQueue(myDispatchQueue)\n</code></pre>"},{"location":"platforms/native/#memory-manager-support","title":"Memory Manager Support","text":"<p>Since Kotlin 1.7.20 enabled the new memory manager by default, Mobius.kt has been updated to support it. The last Mobius.kt version supporting the old memory manager is v1.0.0-rc01.</p>"},{"location":"reference/effect-handler/","title":"Effect Handler","text":""},{"location":"reference/effect-handler/#overview","title":"Overview","text":"<p>Effect Handlers execute Effect messages and potentially produce Events as a result.</p> <p>A Mobius loop has a single Effect Handler, which is usually composed of individual Effect Handlers for Effect type. (See Modules &gt; Coroutines for how to compose Coroutine-based Effect Handlers.)</p> <p>Model data should be passed to the Effect handler within the Effect object. An Effect Handler could subscribe to Model updates at the cost of races and reduce simplicity.</p> <p>Exceptions</p> <p>Effect Handlers can never throw Exceptions, it will cause a crash or put the loop in an unusable state. If an error occurs while executing an Effect, it should be transformed into an <code>Event</code> to be processed by the <code>Update</code> function.</p>"},{"location":"reference/effect-handler/#connections","title":"Connections","text":"<p>Effect Handlers are connected to a <code>MobiusLoop</code> with a <code>Connection</code>, this allows the loop to send Effects to the handler and signal when shut down is required.</p> <p>Effect Handlers that can only be connected to once, which is generally the case, must throw the <code>ConnectionLimitExceeded</code> exception to prevent difficult to identify bugs. If an Effect Handler instance can be shared with multiple loops, ensure that it is prepared to handle it.</p>"},{"location":"reference/effect/","title":"Effect","text":""},{"location":"reference/effect/#overview","title":"Overview","text":"<p>Effect objects allow Update functions to trigger execution of impure code in an Effect Handler. Impure code is any code that has side-effects which prevent the result from being identical given the same parameters. Such code might involve accessing backend HTTP services or reading from a local database.</p> <p>Effect objects are immutable data structures like <code>Events</code> and <code>Models</code>. Both Effects and Events function as messages, but they differ in their purpose within the Update function. Events represent occurrences that require a response from the business logic, while Effects signify actions that the business logic intends to initiate in the external world.</p>"},{"location":"reference/effect/#execution-order","title":"Execution Order","text":"<p>Execution order is not guaranteed</p> <p>Mobius.kt does not make any Effect execution order guarantees. Including cases where two <code>Events</code> trigger <code>Effects</code>, the resulting <code>Effects</code> could execute in any order.</p>"},{"location":"reference/effect/#guidelines-for-effects","title":"Guidelines for Effects","text":"<ul> <li> <p>Use imperative naming conventions that convey the intended action, such   as <code>SubmitLoginRequest</code>, <code>SaveUserToDisk</code>, <code>LoadListData</code>, etc.</p> </li> <li> <p>Ensure Effects are as value objects without business logic.</p> </li> <li> <p>Use <code>sealed class</code> in Kotlin for defining Effect types.</p> </li> </ul>"},{"location":"reference/event-source/","title":"Event Source","text":""},{"location":"reference/event-source/#overview","title":"Overview","text":"<p>Event Sources send external events into a <code>MobiusLoop</code>. You might have external events if you listen to:</p> <ul> <li>Network connection state changes like offline/limit data/etc.</li> <li>Hardware changes like bluetooth connected/disconnected</li> <li>System timers or periodic ticks</li> <li>etc.</li> </ul> <p>Event Sources are like Effect Handlers but do not require Effects before sending any Events.</p> <p>Not for UI events</p> <p>While it's possible to send UI events through an event source, you should instead use <code>MobiusLoop.dispatchEvent(event)</code> or a <code>Connectble</code> when using <code>MobiusLoop.Controller</code>.</p>"},{"location":"reference/event-source/#usage","title":"Usage","text":"<p>You can configure an event source with <code>.eventSource(...)</code> on a <code>MobiusLoop.Builder</code>:</p> <pre><code>val loopBuilder = Mobius.loop(update, effectHandler)\n    .eventSource(myEventSource)\n</code></pre> <p>With Coroutines, you can wrap a <code>Flow&lt;Event&gt;</code> into an <code>EventSource&lt;Event&gt;</code>:</p> <pre><code>val first: Flow&lt;Event.First&gt; = // ...\nval second: Flow&lt;Event.Second&gt; = // ...\nval third: Flow&lt;Event.Third&gt; = // ...\nval eventFlows = merge(first, second, third)\n\nval eventSource = eventFlows.toEventSource()\n</code></pre>"},{"location":"reference/event/","title":"Event","text":""},{"location":"reference/event/#overview","title":"Overview","text":"<p>Events objects are immutable data structures like Effects and Models. Events cause Mobius loops to progress, only Events execute business logic and change the state.</p> <p>Events allow Update functions to process new data to produce side effects or model changes. Events are the only way to put new information in the Update function, which may result in model changes. This means the only way to put new data in the Model is with an Event.</p> <p>As with Model changes Effects can only be triggered by Events because the Update function determines when Effects should occur.</p> <p>Event names should be named with business logic terms instead of UI event terms (ex: <code>LoginRequest</code> is a better name than <code>LoginButtonClicked</code>). This is because there may be more than one way of triggering the same event from the UI. In the <code>LoginRequest</code> case, this may be triggered by a button click or key press event.</p> <p>Not everything in the UI needs to be an Event</p> <p>Animations for example do not always affect business logic, so no Events need to be associated with them. Intermediate animation events most likely don't need to be handled, but there may be an end event to trigger a screen transition.</p>"},{"location":"reference/event/#event-types","title":"Event Types","text":"<p>There are the categories of <code>Events</code> based on the event source: interaction, effect feedback, external:</p> <p>Info</p> <p>This distinction between event types is only useful when reasoning about <code>Events</code>. All events are treated the same in code, the <code>Update</code> function doesn't know anything about the source of the event.</p>"},{"location":"reference/event/#interaction-events","title":"Interaction events","text":"<p>This is the main type of Event, they are considered \u201cthe public API\u201d of a Mobius loop. They are generally triggered by user interaction in the UI (Visual or Terminal based). These Events will usually be actions or intentions rather than the intended effect. For example: <code>UsernameInputChanged</code>, <code>ForgotPasswordClicked</code>, <code>SendPaymentRequested</code>.</p>"},{"location":"reference/event/#effect-feedback-events","title":"Effect feedback events","text":"<p>When Effect Handlers need to provide results to the loop, Effect feedback events are required. For example: Calling a backend API could produce <code>DataLoaded</code> events on success or <code>DataLoadingFailed</code> on errors.</p>"},{"location":"reference/event/#external-events","title":"External events","text":"<p>Events may occur on the platform without user interaction that need to be forwarded into the loop. Some example of these events are: <code>NetworkStateChanged</code>, <code>DeviceDisconnected</code>, <code>PhoneCallStarted</code>.</p>"},{"location":"reference/event/#guidelines-for-events","title":"Guidelines for Events","text":"<ul> <li>Seem more details for defining events at Patterns &gt; Events and Effects.</li> <li>Use names based on user intent in the past tense. For example: <code>LoginRequested</code>, <code>UsernameChanged</code>, etc.</li> </ul>"},{"location":"reference/init/","title":"Init","text":""},{"location":"reference/init/#overview","title":"Overview","text":"<p><code>init(model)</code> functions are called when a Loop is started, they are like Update functions but are only invoked to initialize the loop. It takes the <code>startModel</code> and returns <code>First</code> which always has a Model and possibly a set of Effects.</p> <p>Init functions are especially useful to \"resume\" a new loop instance from a previous Model. For example if the first loop instance is stopped in a <code>Loading</code> state, the associated effect being performed is lost. The Init function could change the state from <code>Loading</code> to <code>Idle</code> or send an effect to restart the work.</p> <p>Warning</p> <p>Providing a custom <code>Init</code> function is optional, but you must ensure the loop does not start in an unrecoverable state for the user.</p>"},{"location":"reference/init/#example","title":"Example","text":"<pre><code>val myInit = Init { model -&gt;\n    if (model.isLoading) {\n        first(model, Effect.LoadData)\n    } else {\n        first(model)\n    }\n}\n</code></pre>"},{"location":"reference/init/#guidelines-for-the-init-function","title":"Guidelines for the Init function","text":"<p><code>Init</code> functions follow the same guidelines as <code>Update</code> functions.</p>"},{"location":"reference/mobius-loop/","title":"Mobius Loop","text":""},{"location":"reference/mobius-loop/#overview","title":"Overview","text":"<p>A Mobius loop processes Events, which are then directed to an Update function. This function can potentially alter the Model and dispatch Effects. The user interface can monitor the Model, while an Effect Handler manages and carries out the Effects.</p> <p></p> <p>The Mobius Loop is the core API which connects all the Mobius components. It invokes the Update function with Events, holds the current Model, sends Effects to an Effect Handler, and observes the Event Source.</p>"},{"location":"reference/mobius-loop/#creation","title":"Creation","text":"<p>A loop can be created using <code>Mobius.loop</code> to provide configuration and <code>startFrom(model)</code> to start it with an initial Model.</p> <pre><code>val loop = Mobius.loop(Example::update, ::createEffectHandler)\n    .startFrom(Model())\n</code></pre>"},{"location":"reference/mobius-loop/#observing","title":"Observing","text":"<p>Use <code>loop.observe(...)</code> to be notified of model changes:</p> <pre><code>val disposable = loop.observe(::onModelChanged)\n\n// To stop receiving updates:\ndisposable.dispose()\n</code></pre> <p>Calling <code>dispose</code> on an observer is only required if the loop will remain running, otherwise <code>loop.dispose()</code> will dispose of observers.</p>"},{"location":"reference/model/","title":"Model","text":""},{"location":"reference/model/#overview","title":"Overview","text":"<p>The Model is an immutable representation of the internal state and configuration of a Mobius loop. It contains two kinds of data, often overlapping: what you need to make business logic decisions, and what you need to present in the UI. Update functions can only consider the current Model and the incoming Event, so data required to produce a result must be stored there.</p> <p>Since the Model is immutable, a new instance will need to be created whenever it needs to change. Because everything is immutable, only a shallow copy is needed so references to a previous model can be shared safely.</p> <p>Resist the temptation to put configuration or state as member fields in your Update function, it will mean that the Update function is not pure. This would make it difficult to reason about the loop in the same way.</p> <p>When starting a Mobius loop, a Model instance is required to start from. This can be the initial state of the loop or a previous Model you want to resume execution from. Since the Update function doesn't have any memory besides the model, all valid Models can be used to start a new loop.</p>"},{"location":"reference/model/#guidelines-for-models","title":"Guidelines for Models","text":"<p>The Model and Event must contain all data needed in the Update function</p> <p>The ensures all data used to make decisions must be in the Model, you should not use state from anywhere else in the loop.</p> <p>The Model should contain all deterministic UI state.</p> <p>Models will inevitably hold UI specific state, but when overdone changes to the UI will be harder to understand and test than Model changes. Simpler UI will produce a more robust loop.</p> <p>Avoid UI concerns in the Model.</p> <p>The Model should primarily be focused on making decisions and not about rendering. Since the Model is an input for rendering, there will be some coupling, but it will be helpful to define the Model in terms of the meaning behind something rather than the representation.</p> <p>For example, prefer a name like <code>canLogin</code> instead of <code>isLoginButtonEnabled</code>. This should be your default strategy for model field naming, but it is sometimes useful for the loop to have UI concerns. In such cases you should determine the best name given your context as UI concerns may be desired/unavoidable, so it is best not to hide it.</p> <p>The Model holds all configuration.</p> <p>In the context, Configuration could mean the user id for loading a specific user profile, or what A/B-test group the user is in.</p> <p>A/B-test naming</p> <p>In the case of an A/B-test flag that changes behavior, it should be expressed as the behavior that is changed, not in terms of what the test is. For example, prefer <code>shouldShowMutalFriends</code> vs <code>isUserInMutualFriendsTestGroup</code>. Translating from A/B-flags to configuration should be done when instantiating your model</p> <p>Do not put behavior in the Model.</p> <p>The Model should be considered a value object. It is okay to put simple helper methods in the Model to make it easier to create new versions of it, but avoid making decisions in it. The Model in Mobius is just an object that holds some data, and shouldn\u2019t be compared to the \u201cmodel\u201d of MVP or MVC, where it usually also contains domain logic.</p>"},{"location":"reference/update/","title":"Update","text":""},{"location":"reference/update/#overview","title":"Overview","text":"<p>Update is an interface with a single <code>update(model, event): Next&lt;Model, Effect&gt;</code> method. It is simply referred to as the Update function. Update functions must be pure, meaning there are some rules to follow:</p>"},{"location":"reference/update/#update-functions-are-pure","title":"Update functions are pure","text":"<p>Update functions must not have side-effects</p> <p>Do not mutate shared memory, interact with disk, log messages, make network requests, etc. If the function is called, it should not change any part of the application. The function should only dispatch Effects describing external work that should be executed.</p> <p>Update functions must not depend on external state</p> <p>The only things that determine the return value of an Update function are the Model and Event parameters. Like before this means not interacting with disk, shared memory, using <code>Random</code> or using the system time. You can also use constants alongside the current Model and Event objects.</p> <p>Configuration of the Update function must be in the Model.</p> <p>Update functions must not have member fields that cause the function to produce different results, even if they are immutable. Any configuration for the Update function should be stored in the Model.</p>"},{"location":"reference/update/#update-functions-return-a-next-object","title":"Update functions return a <code>Next</code> object","text":"<p>The <code>Next</code> class has four states: no change, only Effects, new Model, or both a new Model and effects.</p> <p>The various values can be created with the following factories:</p> <pre><code>Next.noChange()\n\nNext.next(model)\n\nNext.next(model, effects)\n\nNext.dispatch(effects)\n</code></pre> <p>When no Effects are provided, the Update will not emit any effects. If there is no Model provided, then no Model will be emitted to observers.</p>"},{"location":"reference/update/#guidelines-for-update-functions","title":"Guidelines for Update functions","text":"<p>Start by defining expected behaviours of the Update function.</p> <p>Begin by creating unit tests for the Update function. This will help you catch errors and tricky situations in your specifications early, before investing time in developing the Update function, Effect Handlers, and UI.</p> <p>Mobius is a FP pattern.</p> <p>Mobius draws inspiration from functional programming (FP), but it's not always ideal to write code in a purely functional style. There are situations where using a simple for-loop and appending to an array can be more straightforward than employing a higher-order transform function with an anonymous class instance. It's essential to prioritize simplicity and readability in your code and avoid unnecessary complexity.</p> <p>Use mutable data structures inside the Update function.</p> <p>The Update function must only be pure form the outside. If temporary mutable structures can simplify your code, you're encouraged to do so.</p> <p>Large Update functions are not always a bad thing.</p> <p>If the control flow of your Update function is easy to understand, it can become quite large without becoming difficult to reason about. However, it may be beneficial to move individual event handling code into smaller static functions.</p> <p>See Modules &gt; Codegen for utilities to reduce Update function size.</p> <p>Avoid nesting too deeply.</p> <p>An Update function can lead to deeply nested code like when you <code>switch</code> on the Event, then <code>switch</code> on the current state, and then add code to produce a result. In such cases, using smaller functions to handle specific states and Events can be helpful along with other techniques like early returns and local variables for intermediate state.</p>"}]}